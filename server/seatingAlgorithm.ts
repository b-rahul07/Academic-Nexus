import type { User, Room, Seating } from "@shared/schema";

interface GridCell {
  studentId: string | null;
  department: string | null;
}

/**
 * Smart seating algorithm that ensures no two students from the same department
 * sit next to each other (horizontally or vertically, NOT diagonally)
 */
export function allocateSeatingWithConstraints(
  students: User[],
  room: Room
): { grid: GridCell[][]; seatings: Seating[] } {
  const { rows, columns } = room;
  
  // Initialize empty grid
  const grid: GridCell[][] = Array(rows)
    .fill(null)
    .map(() =>
      Array(columns)
        .fill(null)
        .map(() => ({ studentId: null, department: null }))
    );

  // Group students by department
  const byDept = students.reduce(
    (acc, student) => {
      const dept = student.department || "UNKNOWN";
      if (!acc[dept]) acc[dept] = [];
      acc[dept].push(student);
      return acc;
    },
    {} as Record<string, User[]>
  );

  // Shuffle each department
  Object.values(byDept).forEach((group) => {
    for (let i = group.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [group[i], group[j]] = [group[j], group[i]];
    }
  });

  const depts = Object.keys(byDept);
  const iterators = depts.map((d) => byDept[d][Symbol.iterator]());
  let currentDeptIdx = 0;

  // Fill grid using round-robin with conflict checking
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < columns; col++) {
      let placed = false;
      let attempts = 0;

      while (!placed && attempts < depts.length) {
        const dept = depts[currentDeptIdx];
        const iterator = iterators[currentDeptIdx];
        const student = iterator.next().value;

        if (student && !hasAdjacentDept(grid, row, col, dept)) {
          grid[row][col] = { studentId: student.id, department: dept };
          placed = true;
        }

        currentDeptIdx = (currentDeptIdx + 1) % depts.length;
        attempts++;

        if (attempts === depts.length && !placed) {
          // If we can't place due to constraints, relax and place anyway
          if (student) {
            grid[row][col] = { studentId: student.id, department: dept };
            placed = true;
          }
        }
      }
    }
  }

  // Convert grid to seatings array
  const seatings: Seating[] = [];
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < columns; col++) {
      if (grid[row][col].studentId) {
        seatings.push({
          id: "", // Will be generated by DB
          examId: "", // Set by caller
          roomId: "", // Set by caller
          studentId: grid[row][col].studentId!,
          row,
          column: col,
          createdAt: new Date(),
        });
      }
    }
  }

  return { grid, seatings };
}

/**
 * Check if placing a student from a department at (row, col) violates adjacency constraint
 */
function hasAdjacentDept(
  grid: GridCell[][],
  row: number,
  col: number,
  dept: string
): boolean {
  // Check up
  if (row > 0 && grid[row - 1][col].department === dept) return true;
  // Check down
  if (row < grid.length - 1 && grid[row + 1][col].department === dept)
    return true;
  // Check left
  if (col > 0 && grid[row][col - 1].department === dept) return true;
  // Check right
  if (col < grid[row].length - 1 && grid[row][col + 1].department === dept)
    return true;

  return false;
}
